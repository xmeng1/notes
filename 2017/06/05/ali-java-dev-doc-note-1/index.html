<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java,ali," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="有幸发现了阿里的这份 Java 开发手册，可以说算了 Google 的风格指南与惯例（conventions）的一个补充和快速实践手册。个人感觉对开发中有很大的帮助，对一些之前模棱两可的概念有了较为明确的回答。虽然只有30多页，但是目前足以包含开发中大部分问题。接下来针对每一点，尤其是自己之前没有注意过的问题进行解析，目的是在以后开发中应用这些准则。">
<meta name="keywords" content="java,ali">
<meta property="og:type" content="article">
<meta property="og:title" content="阿里Java开发手册笔记-编程规约">
<meta property="og:url" content="https://notes.mengxin.science/2017/06/05/ali-java-dev-doc-note-1/index.html">
<meta property="og:site_name" content="Xin&#39;s Notes">
<meta property="og:description" content="有幸发现了阿里的这份 Java 开发手册，可以说算了 Google 的风格指南与惯例（conventions）的一个补充和快速实践手册。个人感觉对开发中有很大的帮助，对一些之前模棱两可的概念有了较为明确的回答。虽然只有30多页，但是目前足以包含开发中大部分问题。接下来针对每一点，尤其是自己之前没有注意过的问题进行解析，目的是在以后开发中应用这些准则。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-12-21T09:52:36.036Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿里Java开发手册笔记-编程规约">
<meta name="twitter:description" content="有幸发现了阿里的这份 Java 开发手册，可以说算了 Google 的风格指南与惯例（conventions）的一个补充和快速实践手册。个人感觉对开发中有很大的帮助，对一些之前模棱两可的概念有了较为明确的回答。虽然只有30多页，但是目前足以包含开发中大部分问题。接下来针对每一点，尤其是自己之前没有注意过的问题进行解析，目的是在以后开发中应用这些准则。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'LRRR8WO27T',
      apiKey: '52f38cdd494149d36c3b9a986a36836c',
      indexName: 'prod_notes',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://notes.mengxin.science/2017/06/05/ali-java-dev-doc-note-1/"/>





  <title> 阿里Java开发手册笔记-编程规约 | Xin's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-40931165-6', 'auto');
  ga('send', 'pageview');
</script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xin's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Develop Notes</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<div id="google_translate_element"></div><script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'zh-CN', layout: google.translate.TranslateElement.InlineLayout.SIMPLE, multilanguagePage: true, gaTrack: true, gaId: 'UA-40931165-7'}, 'google_translate_element');
}
</script><script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://notes.mengxin.science/2017/06/05/ali-java-dev-doc-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xin Meng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xin's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                阿里Java开发手册笔记-编程规约
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T23:00:00+00:00">
                2017-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发笔记/" itemprop="url" rel="index">
                    <span itemprop="name">开发笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/05/ali-java-dev-doc-note-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/06/05/ali-java-dev-doc-note-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>有幸发现了阿里的这份 Java 开发手册，可以说算了 Google 的风格指南与惯例（conventions）的一个补充和快速实践手册。个人感觉对开发中有很大的帮助，对一些之前模棱两可的概念有了较为明确的回答。虽然只有30多页，但是目前足以包含开发中大部分问题。接下来针对每一点，尤其是自己之前没有注意过的问题进行解析，目的是在以后开发中应用这些准则。</p>
<a id="more"></a>
<p>总体目录如下</p>
<ol>
<li><strong>编程规约</strong></li>
<li>异常日志</li>
<li>MySQL 数据库</li>
<li>工程结构</li>
<li>安全归约</li>
</ol>
<h2 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="(一) 命名风格"></a>(一) 命名风格</h2><h3 id="1-【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"><a href="#1-【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。" class="headerlink" title="1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。*"></a>1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<strong>*</strong></h3><blockquote>
<p>反例：<em>name/__name/$Object/name</em>/name$/Object$</p>
</blockquote>
<p>某些常量我们经常会定义为下划线开头，这是不符合惯例的，实际上这个<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html" target="_blank" rel="noopener">官方 <code>Java</code> 指南</a>介绍的。</p>
<blockquote>
<p>A variable’s name can be any legal identifier — an unlimited-length sequence of Unicode letters and digits, beginning with a letter, the dollar sign “<script type="math/tex">`", or the underscore character "`_`". **The convention, however, is to always begin your variable names with a letter, not "`</script>“ or “<code>_</code>“**. </p>
</blockquote>
<p>另外也<a href="https://zhihu.com/question/27648518/answer/95874180" target="_blank" rel="noopener">有人说</a>使用PMD代码审查时，如果非final变量使用下划线会出现警告提示。（注：<a href="https://pmd.github.io/" target="_blank" rel="noopener">PMD</a> 是一个源码审查器）</p>
<h3 id="2-【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"><a href="#2-【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。" class="headerlink" title="2. 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"></a>2. 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</h3><blockquote>
<p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式 也要避免采用。</p>
<p>正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。<br>反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</p>
</blockquote>
<p>这一点毋庸置疑，可以看看<a href="https://zhihu.com/question/55642203/answer/145953563" target="_blank" rel="noopener">知乎这个回答</a>，在 JUnit 里面使用中文命名….目的是纠正拼写之风…</p>
<h3 id="3-【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：DO-BO-DTO-VO-AO"><a href="#3-【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：DO-BO-DTO-VO-AO" class="headerlink" title="3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO *"></a>3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO <strong>*</strong></h3><blockquote>
<p>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br>反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</p>
</blockquote>
<p>这一点可能后面需要非常注意，每次遇到全大写的名词确实很纠结使用全大写还是驼峰，导致不一致，后面全部使用驼峰来命名。</p>
<h3 id="4-【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从-驼峰形式。"><a href="#4-【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从-驼峰形式。" class="headerlink" title="4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。"></a>4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。</h3><blockquote>
<p>正例： localValue / getHttpMessage() / inputUserId</p>
</blockquote>
<p>这个命名也没有问题，大多数基本都符合这个规则。</p>
<h3 id="5-【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"><a href="#5-【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。" class="headerlink" title="5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"></a>5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</h3><blockquote>
<p>正例： <code>MAX_STOCK_COUNT</code> 反例： <code>MAX_COUNT</code></p>
</blockquote>
<p>这一点也做到了，经常是有多个分隔符来区分不同的常量，以及常量组。</p>
<h3 id="6-【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。"><a href="#6-【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。" class="headerlink" title="6. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。*"></a>6. 【强制】抽象类命名使用 <strong>Abstract</strong> 或 <strong>Base</strong> 开头；异常类命名使用 <strong>Exception</strong> 结尾；测试类命名以它要测试的类的名称开始，以 <strong>Test</strong> 结尾。<strong>*</strong></h3><p>这一点如果使用 spock framework 作为测试框架测试类应该以 <strong>Spec</strong> 结尾。</p>
<h3 id="7-【强制】中括号是数组类型的一部分，数组定义如下：String-args"><a href="#7-【强制】中括号是数组类型的一部分，数组定义如下：String-args" class="headerlink" title="7. 【强制】中括号是数组类型的一部分，数组定义如下：String[] args;*"></a>7. 【强制】中括号是数组类型的一部分，数组定义如下：<code>String[] args</code>;<strong>*</strong></h3><blockquote>
<p>反例：使用 <code>String args[]</code> 的方式来定义。</p>
</blockquote>
<p><a href="https://stackoverflow.com/a/5997297/2000468" target="_blank" rel="noopener">这里有人</a>解释了原因，主要是因为 <code>String[]</code> 在 Java 中是一个对象，所以 <code>String[] args</code> 这种写法更加直观并且作为面向对象编程更有一致性。而另一种写法是兼容 C 语言的语法特性。</p>
<blockquote>
<p>Semantically, they are identical. However, I’d recommend using the latter syntax (<code>String[] args</code>) when declaring arrays. The former syntax <code>String args[]</code> is there mainly for compatibility with C syntax.</p>
<p>Since <code>String[]</code>, as a whole, <strong>is the type of the object in Java, it’s more consistent and clear not to split it up</strong>.</p>
</blockquote>
<h3 id="8-【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。"><a href="#8-【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。" class="headerlink" title="8. 【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。"></a>8. 【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</h3><blockquote>
<p>反例：定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p>
</blockquote>
<p>关于这一点可以参考<a href="https://www.zhihu.com/question/55642203" target="_blank" rel="noopener">知乎的回答</a>，这一点是否参考完全是依赖于整体团队项目代码的，通过这样约束能够减少错误的发生。</p>
<h3 id="9-【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用-单数形式，但是类名如果有复数含义，类名可以使用复数形式。"><a href="#9-【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用-单数形式，但是类名如果有复数含义，类名可以使用复数形式。" class="headerlink" title="9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。"></a>9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。</h3><blockquote>
<p>正例： 应用工具类包名为 com.alibaba.open.util、类名为 <code>MessageUtils</code>（此规则参考 spring 的框架结构）</p>
</blockquote>
<p>目前全部都是这样命名的。</p>
<h3 id="10-【强制】杜绝完全不规范的缩写，避免望文不知义。"><a href="#10-【强制】杜绝完全不规范的缩写，避免望文不知义。" class="headerlink" title="10. 【强制】杜绝完全不规范的缩写，避免望文不知义。"></a>10. 【强制】杜绝完全不规范的缩写，避免望文不知义。</h3><blockquote>
<p>反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p>
</blockquote>
<h3 id="11-【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"><a href="#11-【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。" class="headerlink" title="11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"></a>11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。</h3><blockquote>
<p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。 正例：public class OrderFactory; public class LoginProxy; public class ResourceObserver;</p>
</blockquote>
<h3 id="12-【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁-性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是-与接口方法相关，并且是整个应用的基础常量。"><a href="#12-【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁-性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是-与接口方法相关，并且是整个应用的基础常量。" class="headerlink" title="12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。"></a>12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。</h3><blockquote>
<p>正例：接口方法签名：<code>void f();</code> 接口基础常量表示：<code>String COMPANY = &quot;alibaba&quot;;</code><br>反例：接口方法定义：<code>public abstract void f();</code></p>
<p>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默 认实现。</p>
</blockquote>
<p>这一点可以考虑以后实行，确实接口加修饰的意义不大，作为接口一般都应该是公开的。</p>
<h3 id="13-接口和实现类的命名有两套规则："><a href="#13-接口和实现类的命名有两套规则：" class="headerlink" title="13. 接口和实现类的命名有两套规则："></a>13. 接口和实现类的命名有两套规则：</h3><h4 id="1）【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。"><a href="#1）【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。" class="headerlink" title="1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。"></a>1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</h4><blockquote>
<p>正例：CacheServiceImpl 实现 CacheService 接口。</p>
</blockquote>
<p>目前都是这样使用的，通过 OpenSAML 项目源码阅读对此有了更深刻的理解。</p>
<h4 id="2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。"><a href="#2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。" class="headerlink" title="2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。"></a>2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。</h4><blockquote>
<p>正例：AbstractTranslator 实现 Translatable。</p>
</blockquote>
<p>以后需要注意。</p>
<h3 id="14-【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。"><a href="#14-【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。" class="headerlink" title="14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。"></a>14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</h3><blockquote>
<p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 </p>
<p>正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。</p>
</blockquote>
<p>目前有些枚举没用全大写，后面注意。</p>
<h3 id="15-【参考】各层命名规约："><a href="#15-【参考】各层命名规约：" class="headerlink" title="15. 【参考】各层命名规约："></a>15. 【参考】各层命名规约：</h3><h4 id="A-Service-DAO-层方法命名规约"><a href="#A-Service-DAO-层方法命名规约" class="headerlink" title="A) Service/DAO 层方法命名规约"></a>A) Service/DAO 层方法命名规约</h4><blockquote>
<ol>
<li>获取单个对象的方法用 get 做前缀。</li>
<li>获取多个对象的方法用 list 做前缀。 </li>
<li>获取统计值的方法用 count 做前缀。 </li>
<li>插入的方法用 save（推荐）或 insert 做前缀。 </li>
<li>删除的方法用 remove（推荐）或 delete 做前缀。</li>
<li>修改的方法用 update 做前缀。</li>
</ol>
</blockquote>
<h4 id="B-领域模型命名规约"><a href="#B-领域模型命名规约" class="headerlink" title="B) 领域模型命名规约"></a>B) 领域模型命名规约</h4><blockquote>
<ol>
<li>数据对象：xxxDO，xxx 即为数据表名。 </li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>展示对象：xxxVO，xxx 一般为网页名称。 </li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li>
</ol>
</blockquote>
<p>这一点执行需要考虑并且谨慎，因为 DO 和 DTO 如何区分是一个需要探讨的问题，因为 DO 和 DTO 必然存在重叠的部分，如何正确处理这些重叠的部分是一个问题。</p>
<p>如果我们提供 API，而 API 返回 JSON，那么实际上我们可以在使用 jackson 对 DO 序列化的时候操纵其字段，从而达到传送到客户端的数据是 DO 的子集，可以作为 DTO 的一种变形。</p>
<p>当然如果 DTO 需要新的属性那么就另当别论了。</p>
<p>所以目前决定 DTO 用来约束那些独立于 DO 之外的内容。有可能是多种 DO 的组合，也有可能是一些统计信息等等。</p>
<h2 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二) 常量定义"></a>(二) 常量定义</h2><h3 id="1-【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。"><a href="#1-【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。" class="headerlink" title="1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。"></a>1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。</h3><blockquote>
<p>反例： <code>String key = &quot;Id#taobao_&quot; + tradeId; cache.put(key, value);</code></p>
</blockquote>
<p>所谓魔法数值，是指在代码中直接出现的数值，只有在这个数值记述的那部分代码中才能明确了解其含义。</p>
<p>魔法数值使代码的可读性大大下降。而且，如果同样的数值多次出现时，到底这些数值是不是带有同样的含义呢，谁也说不清楚。另一方面，如果本来应该使用相同数值的地方，一旦用错了，也很难发现。因此，需要注意以下几点，极力避免使用魔法数值。</p>
<h3 id="2-【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字-1-混淆，造成误解。"><a href="#2-【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字-1-混淆，造成误解。" class="headerlink" title="2. 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。"></a>2. 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。</h3><blockquote>
<p>说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?</p>
</blockquote>
<p>l 和 1 确实十分弄混，容易产生 bug。 </p>
<h3 id="3-【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"><a href="#3-【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。" class="headerlink" title="3. 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"></a>3. 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。</h3><blockquote>
<p>如：<br>缓存 相关的常量放在类：CacheConsts 下；<br>系统配置相关的常量放在类：ConfigConsts 下。 </p>
<p>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p>
</blockquote>
<p>这里分类和粒度的掌握是十分重要的，否则分错了类的常量更难查找。</p>
<h3 id="4-【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"><a href="#4-【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。" class="headerlink" title="4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"></a>4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</h3><h4 id="1）-跨应用共享常量：放置在二方库中，通常是-client-jar-中的-constant-目录下。"><a href="#1）-跨应用共享常量：放置在二方库中，通常是-client-jar-中的-constant-目录下。" class="headerlink" title="1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。"></a>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。</h4><h4 id="2）-应用内共享常量：放置在一方库的-modules-中的-constant-目录下。"><a href="#2）-应用内共享常量：放置在一方库的-modules-中的-constant-目录下。" class="headerlink" title="2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。"></a>2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。</h4><blockquote>
<p>反例：易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了表示“是”的变量 类 A 中： public static<br>final String YES = “yes”; 类 B 中： public static final String YES = “y”;<br>A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。</p>
</blockquote>
<h4 id="3）-子工程内部共享常量：即在当前子工程的-constant-目录下。"><a href="#3）-子工程内部共享常量：即在当前子工程的-constant-目录下。" class="headerlink" title="3） 子工程内部共享常量：即在当前子工程的 constant 目录下。"></a>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。</h4><h4 id="4）-包内共享常量：即在当前包下单独的-constant-目录下。"><a href="#4）-包内共享常量：即在当前包下单独的-constant-目录下。" class="headerlink" title="4） 包内共享常量：即在当前包下单独的 constant 目录下。"></a>4） 包内共享常量：即在当前包下单独的 constant 目录下。</h4><h4 id="5）-类内共享常量：直接在类内部-private-static-final-定义。"><a href="#5）-类内共享常量：直接在类内部-private-static-final-定义。" class="headerlink" title="5） 类内共享常量：直接在类内部 private static final 定义。"></a>5） 类内共享常量：直接在类内部 private static final 定义。</h4><h3 id="5-【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。"><a href="#5-【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。" class="headerlink" title="5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。"></a>5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。</h3><blockquote>
<p>下面正例中的数字就是延伸信息，表示星期几。<br>正例：<code>public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}</code></p>
</blockquote>
<h2 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="(三) 代码格式"></a>(三) 代码格式</h2><h3 id="1-【强制】大括号的使用约定。"><a href="#1-【强制】大括号的使用约定。" class="headerlink" title="1. 【强制】大括号的使用约定。"></a>1. 【强制】大括号的使用约定。</h3><blockquote>
<p>如果是大括号内为空，则简洁地写成{}即可，不需要换行；</p>
<p>如果是非空代码块则：<br>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。</p>
</blockquote>
<p>Java 常用的括号风格。</p>
<h3 id="2-【强制】-左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见-第-5-条下方正例提示。"><a href="#2-【强制】-左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见-第-5-条下方正例提示。" class="headerlink" title="2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。"></a>2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。</h3><blockquote>
<p>反例：if (空格 a == b 空格)</p>
</blockquote>
<p>以后详细介绍使用 <strong>checkStyle</strong> 和 <strong>Jetbrains 代码风格文件</strong> 来自动提示和格式化这些排版问题。</p>
<h3 id="3-【强制】if-for-while-switch-do-等保留字与括号之间都必须加空格。"><a href="#3-【强制】if-for-while-switch-do-等保留字与括号之间都必须加空格。" class="headerlink" title="3. 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。"></a>3. 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。</h3><h3 id="4-【强制】任何二目、三目运算符的左右两边都需要加一个空格。"><a href="#4-【强制】任何二目、三目运算符的左右两边都需要加一个空格。" class="headerlink" title="4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。"></a>4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。</h3><blockquote>
<p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p>
</blockquote>
<p>这样能够让二元运算符能从数字或变量中凸现出来，否则找起来十分困难。</p>
<h3 id="5-【强制】缩进采用-4-个空格，禁止使用-tab-字符。"><a href="#5-【强制】缩进采用-4-个空格，禁止使用-tab-字符。" class="headerlink" title="5. 【强制】缩进采用 4 个空格，禁止使用 tab 字符。"></a>5. 【强制】缩进采用 4 个空格，禁止使用 tab 字符。</h3><blockquote>
<p>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时， 请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。</p>
<p>正例： （涉及 1-5 点）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 缩进 4 个空格</span><br><span class="line">    String say = &quot;hello&quot;;</span><br><span class="line">    // 运算符的左右必须有一个空格</span><br><span class="line">    int flag = 0;</span><br><span class="line">    // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格</span><br><span class="line">    if (flag == 0) &#123;</span><br><span class="line">        System.out.println(say);</span><br><span class="line">    &#125;</span><br><span class="line">    // 左大括号前加空格且不换行；左大括号后换行</span><br><span class="line">    if (flag == 1) &#123;</span><br><span class="line">        System.out.println(&quot;world&quot;);</span><br><span class="line">        // 右大括号前换行，右大括号后有 else，不用换行</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">        // 在右大括号后直接结束，则必须换行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这一点缩进4个空格和2个空格是一个永恒的话题，比如谷歌是缩进两个空格，angular 2 的源码代码也是缩进两个空格。实际上只要团队统一风格就好，没有太多的好坏之分。2个空格优点是行短一点，对于现在宽屏幕来说也没什么差别，4个空格是逻辑区块更清晰，所以被更多人接受。</p>
<p>另外值得一提的是一般风格是针对不同的编程语言的，比如如果下载 Google Style 的 Jetbrain 配置文件就会得到一系列编程语言的风格特点。</p>
<p>目前本人使用的在 Google 的基础上修改了 Java 的缩进为 4个空格，同时连续行的缩进是8个空格。当然 Tab 也要定义为 4 个空格。其他语言目前没有变动，有可能 Typescript 开始用2个空格，目前所知，TSLint 默认的检查也是2个空格。</p>
<h3 id="6-【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则："><a href="#6-【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则：" class="headerlink" title="6. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则："></a>6. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</h3><ol>
<li><p>第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</p>
</li>
<li><p>运算符与下文一起换行。</p>
</li>
<li><p>方法调用的点符号与下文一起换行。</p>
</li>
<li><p>在多个参数超长，在逗号后换行。</p>
</li>
<li><p>在括号前不要换行，见反例。</p>
</li>
</ol>
<blockquote>
<p>正例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行</span></span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...</span><br><span class="line"></span><br><span class="line">.append(<span class="string">"huang"</span>)...</span><br><span class="line"></span><br><span class="line">.append(<span class="string">"huang"</span>)...</span><br><span class="line"></span><br><span class="line">.append(<span class="string">"huang"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...append</span><br><span class="line"></span><br><span class="line">(<span class="string">"huang"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span><br><span class="line"></span><br><span class="line">method(args1, args2, args3, ...</span><br><span class="line"></span><br><span class="line">, argsX);</span><br></pre></td></tr></table></figure>
<p>这里一般都是使用 Jetbrain 的快捷键，全选然后 <code>Ctrl+Alt+L</code> 来格式化代码，这个格式化是根据配置的风格文件的，比如前面提到的 Google Style。</p>
<h3 id="7-【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"><a href="#7-【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。" class="headerlink" title="7. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"></a>7. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。</h3><blockquote>
<p>正例：下例中实参的”a”,后边必须要有一个空格。</p>
<p><code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></p>
</blockquote>
<h3 id="8-【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。"><a href="#8-【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。" class="headerlink" title="8. 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。"></a>8. 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。</h3><p>这个毋庸置疑，对于开发来讲尽可能脱离 Windows 特有的约束。</p>
<h3 id="9-【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。"><a href="#9-【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。" class="headerlink" title="9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。"></a>9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。</h3><blockquote>
<p>正例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> b = <span class="number">4L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> c = <span class="number">5F</span>;</span><br><span class="line"></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的 情况下，是一种累赘的事情。</p>
</blockquote>
<p>以前还真为这个事情操过心，轻度强迫症。但是后来发现，只要改一点东西，辛苦对齐了半天的内容瞬间破坏了。这一条算是吃个定心丸吧，以后不折腾这个对齐了。</p>
<h3 id="10-【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义-之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。"><a href="#10-【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义-之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。" class="headerlink" title="10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义 之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。"></a>10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义 之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。</h3><blockquote>
<p>说明：没有必要插入<strong>多个空行</strong>进行隔开。</p>
</blockquote>
<h2 id="四-OOP-规约"><a href="#四-OOP-规约" class="headerlink" title="(四) OOP 规约"></a>(四) OOP 规约</h2><h3 id="1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成-本，直接用类名来访问即可。"><a href="#1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成-本，直接用类名来访问即可。" class="headerlink" title="1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。"></a>1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用<strong>类名</strong>来访问即可。</h3><p>静态方法强制使用静态的访问方式，提高效率。同时对于工具类尽可能考虑是否有必要提供静态方法。</p>
<h3 id="2-【强制】所有的覆写方法，必须加-Override-注解。"><a href="#2-【强制】所有的覆写方法，必须加-Override-注解。" class="headerlink" title="2. 【强制】所有的覆写方法，必须加@Override 注解。"></a>2. 【强制】所有的覆写方法，必须加@Override 注解。</h3><blockquote>
<p>说明<code>：getObject()</code>与 <code>get0bject()</code>的问题。一个是字母的 O，一个是数字的 0，加 <code>@Override</code> 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p>
</blockquote>
<h3 id="3-【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。"><a href="#3-【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。" class="headerlink" title="3. 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。"></a>3. 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。</h3><blockquote>
<p>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）</p>
<p>正例：<code>public User getUsers(String type, Integer... ids) {...}</code></p>
</blockquote>
<p>好像基本没怎么用过…</p>
<h3 id="4-【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生-影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。"><a href="#4-【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生-影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。" class="headerlink" title="4. 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。"></a>4. 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。接口过时必须加<code>@Deprecated</code> 注解，并清晰地说明采用的新接口或者新服务是什么。</h3><h3 id="5-【强制】不能使用过时的类或方法。"><a href="#5-【强制】不能使用过时的类或方法。" class="headerlink" title="5. 【强制】不能使用过时的类或方法。"></a>5. 【强制】不能使用过时的类或方法。</h3><blockquote>
<p>说明：java.net.URLDecoder 中的方法 <code>decode(String encodeStr)</code> 这个方法已经过时，应该使用双参数 <code>decode(String source, String encode)</code>。接口提供方既然明确是过时接口， 那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p>
</blockquote>
<h3 id="6-【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用-equals。"><a href="#6-【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用-equals。" class="headerlink" title="6. 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。"></a>6. 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</h3><blockquote>
<p>正例： “test”.equals(object);</p>
<p>反例： object.equals(“test”); </p>
<p>说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）</p>
</blockquote>
<p>这一点需要非常注意，这样能够很好的避免空指针。</p>
<h3 id="7-【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。"><a href="#7-【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。" class="headerlink" title="7. 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。"></a>7. 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。</h3><blockquote>
<p>说明：对于 <code>Integer var = ?</code> 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用<code>==</code>进行 判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑， 推荐使用 equals 方法进行判断。</p>
</blockquote>
<p>这个坑需要深入理解。</p>
<h3 id="8-关于基本数据类型与包装数据类型的使用标准如下："><a href="#8-关于基本数据类型与包装数据类型的使用标准如下：" class="headerlink" title="8. 关于基本数据类型与包装数据类型的使用标准如下："></a>8. 关于基本数据类型与包装数据类型的使用标准如下：</h3><h4 id="1）【强制】所有的-POJO-类属性必须使用包装数据类型。"><a href="#1）【强制】所有的-POJO-类属性必须使用包装数据类型。" class="headerlink" title="1）【强制】所有的 POJO 类属性必须使用包装数据类型。"></a>1）【强制】所有的 POJO 类属性必须使用包装数据类型。</h4><h4 id="2）【强制】RPC-方法的返回值和参数必须使用包装数据类型。"><a href="#2）【强制】RPC-方法的返回值和参数必须使用包装数据类型。" class="headerlink" title="2）【强制】RPC 方法的返回值和参数必须使用包装数据类型。"></a>2）【强制】RPC 方法的返回值和参数必须使用包装数据类型。</h4><h4 id="3）【推荐】所有的局部变量使用基本数据类型。"><a href="#3）【推荐】所有的局部变量使用基本数据类型。" class="headerlink" title="3）【推荐】所有的局部变量使用基本数据类型。"></a>3）【推荐】所有的局部变量使用基本数据类型。</h4><blockquote>
<p>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p>
<p>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p>
<p>反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装 数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出<br>。</p>
</blockquote>
<h3 id="9-【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。"><a href="#9-【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。" class="headerlink" title="9. 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。"></a>9. 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。</h3><blockquote>
<p>反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p>
</blockquote>
<h3 id="10-【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如-果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。"><a href="#10-【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如-果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。" class="headerlink" title="10. 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。"></a>10. 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</h3><blockquote>
<p>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>
</blockquote>
<h3 id="11-【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。"><a href="#11-【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。" class="headerlink" title="11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。"></a>11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</h3><h3 id="12-【强制】POJO-类必须写-toString-方法。使用-IDE-的中工具：source-gt-generate-toString-时，如果继承了另一个-POJO-类，注意在前面加一下-super-toString。"><a href="#12-【强制】POJO-类必须写-toString-方法。使用-IDE-的中工具：source-gt-generate-toString-时，如果继承了另一个-POJO-类，注意在前面加一下-super-toString。" class="headerlink" title="12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。"></a>12. 【强制】POJO 类必须写 <code>toString</code> 方法。使用 IDE 的中工具：<code>source&gt; generate toString</code> 时，如果继承了另一个 POJO 类，注意在前面加一下 <code>super.toString</code>。</h3><blockquote>
<p>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p>
</blockquote>
<h3 id="13-【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。"><a href="#13-【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。" class="headerlink" title="13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。"></a>13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。</h3><p>说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"a,b,c,,"</span>;</span><br><span class="line"></span><br><span class="line">String[] ary = str.split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//预期大于 3，结果是 3</span></span><br><span class="line"></span><br><span class="line">System.out.println(ary.length);</span><br></pre></td></tr></table></figure>
<h3 id="14-【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，-便于阅读。"><a href="#14-【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，-便于阅读。" class="headerlink" title="14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起， 便于阅读。"></a>14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起， 便于阅读。</h3><h3 id="15-【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter-方法。"><a href="#15-【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter-方法。" class="headerlink" title="15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方法。"></a>15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方法。</h3><blockquote>
<p>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个 黑盒实现；因为方法信息价值较低，所有 <code>Service</code> 和 <code>DAO</code> 的 <code>getter/setter</code> 方法放在类体最后。</p>
</blockquote>
<p>公开的方法最重要，最值得其他人关心。</p>
<h3 id="16-【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在-getter-setter-方法中，不要增加业务逻辑，增加排查问题的难度。"><a href="#16-【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在-getter-setter-方法中，不要增加业务逻辑，增加排查问题的难度。" class="headerlink" title="16. 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。"></a>16. 【推荐】<code>setter</code> 方法中，参数名称与类成员变量名称一致，<code>this.成员名 = 参数名</code>。在 <code>getter/setter</code> 方法中，不要增加业务逻辑，增加排查问题的难度。</h3><p>反例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data + <span class="number">100</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data - <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-【推荐】循环体内，字符串的连接方式，使用-StringBuilder-的-append-方法进行扩展。"><a href="#17-【推荐】循环体内，字符串的连接方式，使用-StringBuilder-的-append-方法进行扩展。" class="headerlink" title="17. 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。"></a>17. 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</h3><blockquote>
<p>说明：反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行 <code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。</p>
</blockquote>
<p>反例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"start"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-【推荐】final-可以声明类、成员变量、方法、以及本地变量，下列情况使用final-关键字："><a href="#18-【推荐】final-可以声明类、成员变量、方法、以及本地变量，下列情况使用final-关键字：" class="headerlink" title="18.【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用final 关键字："></a>18.【推荐】<code>final</code> 可以声明类、成员变量、方法、以及本地变量，下列情况使用<code>final</code> 关键字：</h3><ol>
<li>不允许被继承的类，如：<code>String</code> 类。</li>
<li>不允许修改引用的域对象，如：<code>POJO</code> 类的域变量。</li>
<li>不允许被重写的方法，如：<code>POJO</code> 类的 <code>setter</code> 方法。</li>
<li>不允许运行过程中重新赋值的局部变量。</li>
<li>避免上下文重复使用一个变量，使用 <code>final</code> 描述可以强制重新定义一个变量，方便更好地进行重构。</li>
</ol>
<h3 id="19-【推荐】慎用-Object-的-clone-方法来拷贝对象。"><a href="#19-【推荐】慎用-Object-的-clone-方法来拷贝对象。" class="headerlink" title="19. 【推荐】慎用 Object 的 clone 方法来拷贝对象。"></a>19. 【推荐】慎用 Object 的 clone 方法来拷贝对象。</h3><blockquote>
<p>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象 的拷贝。</p>
</blockquote>
<h3 id="20-【推荐】类成员与方法访问控制从严："><a href="#20-【推荐】类成员与方法访问控制从严：" class="headerlink" title="20. 【推荐】类成员与方法访问控制从严："></a>20. 【推荐】类成员与方法访问控制从严：</h3><p>1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。<br>2） 工具类不允许有 public 或 default 构造方法。<br>3） 类非 static 成员变量并且与子类共享，必须是 protected。<br>4） 类非 static 成员变量并且仅在本类使用，必须是 private。<br>5） 类 static 成员变量如果仅在本类使用，必须是 private。<br>6） 若是 static 成员变量，必须考虑是否为 final。<br>7） 类成员方法只供类内部调用，必须是 private。<br>8） 类成员方法只对继承类公开，那么限制为 protected。</p>
<blockquote>
<p>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 </p>
<p>思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者 一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p>
</blockquote>
<h2 id="五-集合处理"><a href="#五-集合处理" class="headerlink" title="(五) 集合处理"></a>(五) 集合处理</h2><h3 id="1-【强制】关于-hashCode-和-equals-的处理，遵循如下规则："><a href="#1-【强制】关于-hashCode-和-equals-的处理，遵循如下规则：" class="headerlink" title="1. 【强制】关于 hashCode 和 equals 的处理，遵循如下规则："></a>1. 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</h3><p>1） 只要重写 equals，就必须重写 hashCode。 </p>
<p>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。 </p>
<p>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。 </p>
<blockquote>
<p>说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。</p>
</blockquote>
<h3 id="2-【强制】ArrayList-的-subList-结果不可强转成-ArrayList，否则会抛出-ClassCastException"><a href="#2-【强制】ArrayList-的-subList-结果不可强转成-ArrayList，否则会抛出-ClassCastException" class="headerlink" title="2. 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException"></a>2. 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException</h3><blockquote>
<p>异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList;</p>
<p>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p>
</blockquote>
<h3 id="3-【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增-加、删除均产生-ConcurrentModificationException-异常。"><a href="#3-【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增-加、删除均产生-ConcurrentModificationException-异常。" class="headerlink" title="3. 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 ConcurrentModificationException 异常。"></a>3. 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 ConcurrentModificationException 异常。</h3><h3 id="4-【强制】使用集合转数组的方法，必须使用集合的-toArray-T-array-，传入的是类型完全一样的数组，大小就是-list-size-。"><a href="#4-【强制】使用集合转数组的方法，必须使用集合的-toArray-T-array-，传入的是类型完全一样的数组，大小就是-list-size-。" class="headerlink" title="4. 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。"></a>4. 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。</h3><blockquote>
<p>说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组 元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素 个数一致。</p>
<p>正例：</p>
<figure class="highlight java"><figcaption><span>List<string> list </string></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; list.add(<span class="string">"guan"</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; list.add(<span class="string">"bao"</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; String[] array = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">&gt; </span><br><span class="line">&gt; array = list.toArray(array);</span><br></pre></td></tr></table></figure>
<p>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它 类型数组将出现 ClassCastException 错误。</p>
</blockquote>
<h3 id="5-【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。"><a href="#5-【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。" class="headerlink" title="5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。"></a>5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</h3><blockquote>
<p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span> &#125;; </span><br><span class="line"></span><br><span class="line">List list = Arrays.asList(str);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一种情况：list.add(“c”); 运行时异常。<br>第二种情况：str[0] = “gujin”; 那么list.get(0)也会随之修改。</p>
</blockquote>
<h3 id="6-【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方-法，而-lt-super-T-gt-不能使用-get-方法，做为接口调用赋值时易出错。"><a href="#6-【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方-法，而-lt-super-T-gt-不能使用-get-方法，做为接口调用赋值时易出错。" class="headerlink" title="6. 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而&lt;? super T&gt;不能使用 get 方法，做为接口调用赋值时易出错。"></a>6. 【强制】泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而<code>&lt;? super T&gt;</code>不能使用 <code>get</code> 方法，做为接口调用赋值时易出错。</h3><blockquote>
<p>说明：扩展说一下 PECS(Producer Extends Consumer Super) 原则：1）频繁往外读取内容的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。</p>
</blockquote>
<h3 id="7-【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterato-方式，如果并发操作，需要对-Iterator-对象加锁。"><a href="#7-【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterato-方式，如果并发操作，需要对-Iterator-对象加锁。" class="headerlink" title="7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterato 方式，如果并发操作，需要对 Iterator 对象加锁。"></a>7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterato 方式，如果并发操作，需要对 Iterator 对象加锁。</h3><blockquote>
<p>正例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = a.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    String temp = it.next();</span><br><span class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">a.add(<span class="string">"1"</span>);</span><br><span class="line">a.add(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span> (String temp : a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(temp)) &#123;</span><br><span class="line">        a.remove(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的 结果吗？</p>
</blockquote>
<p><a href="https://github.com/xmeng1/ali-style-demo" target="_blank" rel="noopener">这一个已经尝试过了</a>，会返回异常 <code>java.util.ConcurrentModificationException</code>。因为如果换成2， 那么当 “2”.equals(temp)，就会把末尾的2删除，但是这时候循环并没有结束，还需要去判断是否应该退出循环，退出时就会检查当前的游标是否超过总数，但是在检查时，由于原数组已经发生了更改，所以倒是出现一个并发修改的异常。</p>
<h3 id="8-【强制】-在-JDK7-版本及以上，Comparator-要满足如下三个条件，不然-Arrays-sort，Collections-sort-会报-IllegalArgumentException-异常。"><a href="#8-【强制】-在-JDK7-版本及以上，Comparator-要满足如下三个条件，不然-Arrays-sort，Collections-sort-会报-IllegalArgumentException-异常。" class="headerlink" title="8. 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。"></a>8. 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 <code>Arrays.sort</code>，<code>Collections.sort</code> 会报 <code>IllegalArgumentException</code> 异常。</h3><blockquote>
<p>说明：<br>1） x，y 的比较结果和 y，x 的比较结果相反。<br>2） x&gt;y，y&gt;z，则 x&gt;z。<br>3） x=y，则 x，z 比较结果和 y，z 比较结果相同。</p>
<p>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-【推荐】集合初始化时，指定集合初始值大小。"><a href="#9-【推荐】集合初始化时，指定集合初始值大小。" class="headerlink" title="9. 【推荐】集合初始化时，指定集合初始值大小。"></a>9. 【推荐】集合初始化时，指定集合初始值大小。</h3><blockquote>
<p>说明：HashMap 使用 HashMap(int initialCapacity) 初始化，</p>
<p>正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为16。</p>
<p>反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。</p>
</blockquote>
<h3 id="10-【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。"><a href="#10-【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。" class="headerlink" title="10. 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。"></a>10. 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</h3><blockquote>
<p>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。</p>
<p>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。</p>
</blockquote>
<h3 id="11-【推荐】高度注意-Map-类集合-K-V-能不能存储-null-值的情况，如下表格："><a href="#11-【推荐】高度注意-Map-类集合-K-V-能不能存储-null-值的情况，如下表格：" class="headerlink" title="11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格："></a>11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</h3><div class="table-container">
<table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>分段锁技术</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上， 存储 null 值时会抛出 NPE 异常。</p>
</blockquote>
<h3 id="12-【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。"><a href="#12-【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。" class="headerlink" title="12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。"></a>12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</h3><blockquote>
<p>说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次 序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。</p>
</blockquote>
<h3 id="13-【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的-contains-方法进行遍历、对比、去重操作。"><a href="#13-【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的-contains-方法进行遍历、对比、去重操作。" class="headerlink" title="13. 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。"></a>13. 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。</h3><h2 id="六-并发处理"><a href="#六-并发处理" class="headerlink" title="(六) 并发处理"></a>(六) 并发处理</h2><h3 id="1-【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><a href="#1-【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。" class="headerlink" title="1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"></a>1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h3><blockquote>
<p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p>
</blockquote>
<h3 id="2-【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><a href="#2-【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。" class="headerlink" title="2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"></a>2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h3><blockquote>
<p>正例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"><a href="#3-【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。" class="headerlink" title="3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"></a>3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</h3><blockquote>
<p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换” 的问题。</p>
</blockquote>
<h3 id="4-【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"><a href="#4-【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。" class="headerlink" title="4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"></a>4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</h3><blockquote>
<p>说明：Executors 返回的线程池对象的弊端如下：</p>
<p>1）FixedThreadPool 和 SingleThreadPool:</p>
<p>允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p>
<p>2）CachedThreadPool 和 ScheduledThreadPool:</p>
<p>允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>
</blockquote>
<h3 id="5-【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。"><a href="#5-【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。" class="headerlink" title="5. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。"></a>5. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。</h3><blockquote>
<p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。</p>
</blockquote>
<h3 id="6-【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能-锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"><a href="#6-【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能-锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。" class="headerlink" title="6. 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"></a>6. 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h3><blockquote>
<p>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</p>
</blockquote>
<h3 id="7-【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造-成死锁。"><a href="#7-【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造-成死锁。" class="headerlink" title="7. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。"></a>7. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。</h3><blockquote>
<p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序 也必须是 A、B、C，否则可能出现死锁。</p>
</blockquote>
<h3 id="8-【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加-锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。"><a href="#8-【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加-锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。" class="headerlink" title="8. 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。"></a>8. 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</h3><blockquote>
<p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。</p>
</blockquote>
<h3 id="9-【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获-抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。"><a href="#9-【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获-抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。" class="headerlink" title="9. 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获 抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。"></a>9. 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获 抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</h3><h3 id="10-【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行-至-await-方法，直到超时才返回结果。"><a href="#10-【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行-至-await-方法，直到超时才返回结果。" class="headerlink" title="10. 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行 至 await 方法，直到超时才返回结果。"></a>10. 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行 至 await 方法，直到超时才返回结果。</h3><blockquote>
<p>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p>
</blockquote>
<h3 id="11-【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。"><a href="#11-【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。" class="headerlink" title="11. 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。"></a>11. 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</h3><blockquote>
<p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。</p>
<p>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例。</p>
</blockquote>
<h3 id="12-【推荐】在并发场景下，通过双重检查锁（double-checked-locking）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-，推荐问-题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。"><a href="#12-【推荐】在并发场景下，通过双重检查锁（double-checked-locking）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-，推荐问-题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。" class="headerlink" title="12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问 题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。"></a>12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问 题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。</h3><blockquote>
<p>反例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (helper == <span class="keyword">null</span>) <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">        helper = <span class="keyword">new</span> Helper();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other functions and members...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-【参考】volatile-解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，-但是如果多写，同样无法解决线程安全问题。如果是-count-操作，使用如下类实现：-AtomicInteger-count-new-AtomicInteger-count-addAndGet-1-如果是-JDK8，推荐使用-LongAdder-对象，比-AtomicLong-性能更好（减少乐观锁的重试次数）。"><a href="#13-【参考】volatile-解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，-但是如果多写，同样无法解决线程安全问题。如果是-count-操作，使用如下类实现：-AtomicInteger-count-new-AtomicInteger-count-addAndGet-1-如果是-JDK8，推荐使用-LongAdder-对象，比-AtomicLong-性能更好（减少乐观锁的重试次数）。" class="headerlink" title="13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。"></a>13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</h3><h3 id="14-【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在-开发过程中可以使用其它数据结构或加锁来规避此风险。"><a href="#14-【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在-开发过程中可以使用其它数据结构或加锁来规避此风险。" class="headerlink" title="14. 【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在 开发过程中可以使用其它数据结构或加锁来规避此风险。"></a>14. 【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在 开发过程中可以使用其它数据结构或加锁来规避此风险。</h3><h3 id="15-【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享-此静态变量-，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象-只-要是这个线程内定义的-都可以操控这个变量。"><a href="#15-【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享-此静态变量-，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象-只-要是这个线程内定义的-都可以操控这个变量。" class="headerlink" title="15. 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享 此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。"></a>15. 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享 此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。</h3><h2 id="七-控制语句"><a href="#七-控制语句" class="headerlink" title="(七) 控制语句"></a>(七) 控制语句</h2><h3 id="1-【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；在一个-switch-块内，都必须包含一个-default-语句并且-放在最后，即使它什么代码也没有。"><a href="#1-【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；在一个-switch-块内，都必须包含一个-default-语句并且-放在最后，即使它什么代码也没有。" class="headerlink" title="1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且 放在最后，即使它什么代码也没有。"></a>1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且 放在最后，即使它什么代码也没有。</h3><h3 id="2-【强制】在-if-else-for-while-do-语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if-condition-statements"><a href="#2-【强制】在-if-else-for-while-do-语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if-condition-statements" class="headerlink" title="2. 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;"></a>2. 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;</h3><h3 id="3-【推荐】表达异常的分支时，少用-if-else-方式，这种方式可以改写成："><a href="#3-【推荐】表达异常的分支时，少用-if-else-方式，这种方式可以改写成：" class="headerlink" title="3. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成："></a>3. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着写 else 的业务逻辑代码;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维 护困难，请勿超过 3 层。</p>
<p>正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例 如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBusy()) &#123;</span><br><span class="line">        System.out.println(“change time.”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFree()) &#123;</span><br><span class="line">        System.out.println(“go to travel.”);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复-杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"><a href="#4-【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复-杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。" class="headerlink" title="4. 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复 杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"></a>4. 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复 杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</h3><blockquote>
<p>说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？</p>
<p>正例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码如下</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);</span><br><span class="line"><span class="keyword">if</span> (existed) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、-获取数据库连接，进行不必要的-try-catch-操作（这个-try-catch-是否可以移至循环体外）。"><a href="#5-【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、-获取数据库连接，进行不必要的-try-catch-操作（这个-try-catch-是否可以移至循环体外）。" class="headerlink" title="5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、 获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。"></a>5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、 获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</h3><h3 id="6-【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"><a href="#6-【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。" class="headerlink" title="6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"></a>6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</h3><h3 id="7-【参考】下列情形，需要进行参数校验："><a href="#7-【参考】下列情形，需要进行参数校验：" class="headerlink" title="7. 【参考】下列情形，需要进行参数校验："></a>7. 【参考】下列情形，需要进行参数校验：</h3><blockquote>
<p>1） 调用频次低的方法。<br>2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。<br>3） 需要极高稳定性和可用性的方法。<br>4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。<br>5） 敏感权限入口。</p>
</blockquote>
<h3 id="8-【参考】下列情形，不需要进行参数校验："><a href="#8-【参考】下列情形，不需要进行参数校验：" class="headerlink" title="8. 【参考】下列情形，不需要进行参数校验："></a>8. 【参考】下列情形，不需要进行参数校验：</h3><blockquote>
<p>1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。<br>2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底 层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所 以 DAO 的参数校验，可以省略。<br>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参 数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p>
</blockquote>
<h2 id="八-注释规约"><a href="#八-注释规约" class="headerlink" title="(八) 注释规约"></a>(八) 注释规约</h2><h3 id="1-【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。"><a href="#1-【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。" class="headerlink" title="1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用 //xxx 方式。"></a>1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/<em>*内容</em>/格式，不得使用 //xxx 方式。</h3><blockquote>
<p>说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注 释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高 阅读效率。</p>
</blockquote>
<h3 id="2-【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、-异常说明外，还必须指出该方法做什么事情，实现什么功能。"><a href="#2-【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、-异常说明外，还必须指出该方法做什么事情，实现什么功能。" class="headerlink" title="2. 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。"></a>2. 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</h3><blockquote>
<p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p>
</blockquote>
<h3 id="3-【强制】所有的类都必须添加创建者和创建日期。"><a href="#3-【强制】所有的类都必须添加创建者和创建日期。" class="headerlink" title="3. 【强制】所有的类都必须添加创建者和创建日期。"></a>3. 【强制】所有的类都必须添加创建者和创建日期。</h3><h3 id="4-【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释-使用-注释，注意与代码对齐。"><a href="#4-【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释-使用-注释，注意与代码对齐。" class="headerlink" title="4. 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释 使用/ /注释，注意与代码对齐。"></a>4. 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释 使用/<em> </em>/注释，注意与代码对齐。</h3><h3 id="5-【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"><a href="#5-【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。" class="headerlink" title="5. 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"></a>5. 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</h3><h3 id="6-【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持-英文原文即可。"><a href="#6-【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持-英文原文即可。" class="headerlink" title="6. 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可。"></a>6. 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可。</h3><blockquote>
<p>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p>
</blockquote>
<h3 id="7-【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑-等的修改。"><a href="#7-【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑-等的修改。" class="headerlink" title="7. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。"></a>7. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。</h3><blockquote>
<p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。</p>
</blockquote>
<h3 id="8-【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。"><a href="#8-【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。" class="headerlink" title="8. 【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。"></a>8. 【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。</h3><blockquote>
<p>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p>
</blockquote>
<h3 id="9-【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含-义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同-天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看-的，使其能够快速接替自己的工作。"><a href="#9-【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含-义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同-天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看-的，使其能够快速接替自己的工作。" class="headerlink" title="9. 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看 的，使其能够快速接替自己的工作。"></a>9. 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看 的，使其能够快速接替自己的工作。</h3><h3 id="10-【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的-一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。"><a href="#10-【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的-一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。" class="headerlink" title="10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的 一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。"></a>10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的 一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</h3><blockquote>
<p>反例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put elephant into fridge</span></span><br><span class="line">put(elephant, fridge);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语 义清晰的代码不需要额外的注释。</p>
</blockquote>
<h3 id="11-【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，-经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。"><a href="#11-【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，-经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。" class="headerlink" title="11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。"></a>11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</h3><blockquote>
<p>1） 待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc  还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。</p>
<p>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p>
</blockquote>
<h2 id="九-其它"><a href="#九-其它" class="headerlink" title="(九) 其它"></a>(九) 其它</h2><h3 id="1-【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><a href="#1-【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。" class="headerlink" title="1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"></a>1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h3><blockquote>
<p>说明：不要在方法体内定义：<code>Pattern pattern = Pattern.compile(规则);</code></p>
</blockquote>
<h3 id="2-【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，模板引擎会自动按-规范调用-POJO-的-getXxx-，如果是-boolean-基本数据类型变量（boolean-命名不需要加-is前缀），会自动调用-isXxx-方法。"><a href="#2-【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，模板引擎会自动按-规范调用-POJO-的-getXxx-，如果是-boolean-基本数据类型变量（boolean-命名不需要加-is前缀），会自动调用-isXxx-方法。" class="headerlink" title="2. 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按 规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。"></a>2. 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按 规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。</h3><blockquote>
<p>说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p>
</blockquote>
<h3 id="3-【强制】后台输送给页面的变量必须加-var-——中间的感叹号。"><a href="#3-【强制】后台输送给页面的变量必须加-var-——中间的感叹号。" class="headerlink" title="3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。"></a>3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。</h3><blockquote>
<p>说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。</p>
</blockquote>
<h3 id="4-【强制】注意-Math-random-这个方法返回是-double-类型，注意取值的范围-0≤x-lt-1（能够-取到零值，注意除零异常），如果想获取整数类型的随机数，不要将-x-放大-10-的若干倍然后-取整，直接使用-Random-对象的-nextInt-或者-nextLong-方法。"><a href="#4-【强制】注意-Math-random-这个方法返回是-double-类型，注意取值的范围-0≤x-lt-1（能够-取到零值，注意除零异常），如果想获取整数类型的随机数，不要将-x-放大-10-的若干倍然后-取整，直接使用-Random-对象的-nextInt-或者-nextLong-方法。" class="headerlink" title="4. 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。"></a>4. 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</h3><h3 id="5-【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime"><a href="#5-【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime" class="headerlink" title="5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();"></a>5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</h3><blockquote>
<p>说明：如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中， 针对统计时间等场景，推荐使用 Instant 类。</p>
</blockquote>
<h3 id="6-【推荐】不要在视图模板中加入任何复杂的逻辑。"><a href="#6-【推荐】不要在视图模板中加入任何复杂的逻辑。" class="headerlink" title="6. 【推荐】不要在视图模板中加入任何复杂的逻辑。"></a>6. 【推荐】不要在视图模板中加入任何复杂的逻辑。</h3><blockquote>
<p>说明：根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。</p>
</blockquote>
<h3 id="7-【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"><a href="#7-【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。" class="headerlink" title="7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"></a>7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</h3><h3 id="8-【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性-等要坚决从程序中清理出去，避免造成过多垃圾。"><a href="#8-【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性-等要坚决从程序中清理出去，避免造成过多垃圾。" class="headerlink" title="8. 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性 等要坚决从程序中清理出去，避免造成过多垃圾。"></a>8. 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性 等要坚决从程序中清理出去，避免造成过多垃圾。</h3>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/ali/" rel="tag"># ali</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/03/nexus-3-docker-maven/" rel="next" title="使用docker(Nexus-3.3-OOS)自建Maven私服">
                <i class="fa fa-chevron-left"></i> 使用docker(Nexus-3.3-OOS)自建Maven私服
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/09/different-base64-encode-research/" rel="prev" title="关于在线Base64编码不一致的问题研究">
                关于在线Base64编码不一致的问题研究 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
      
        
          <ul class="sidebar-nav motion-element">
            <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
              文章目录
            </li>
            <li class="sidebar-nav-overview" data-target="site-overview">
              站点概览
            </li>
          </ul>
        
      



      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar-2.jpg"
               alt="Xin Meng" />
          <p class="site-author-name" itemprop="name">Xin Meng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">152</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">162</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xmeng1" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/xinmeng_1" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/michealmeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.linkedin.com/in/xinmeng1" target="_blank" title="Linkedin">
                  
                    <i class="fa fa-fw fa-linkedin"></i>
                  
                  Linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/mengxin.city" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                  Facebook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/xinmeng1" target="_blank" title="Douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Douban
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/xinmeng1" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Next
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://theme-next.iissnan.com" title="Title" target="_blank">Title</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>
      
        
        <!--noindex-->
          <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
            <div class="post-toc">

              
                
              

              
                <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-命名风格"><span class="nav-number">1.</span> <span class="nav-text">(一) 命名风格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"><span class="nav-number">1.1.</span> <span class="nav-text">1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。"><span class="nav-number">1.2.</span> <span class="nav-text">2. 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式，但以下情形例外：DO-BO-DTO-VO-AO"><span class="nav-number">1.3.</span> <span class="nav-text">3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从-驼峰形式。"><span class="nav-number">1.4.</span> <span class="nav-text">4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。"><span class="nav-number">1.5.</span> <span class="nav-text">5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾。"><span class="nav-number">1.6.</span> <span class="nav-text">6. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【强制】中括号是数组类型的一部分，数组定义如下：String-args"><span class="nav-number">1.7.</span> <span class="nav-text">7. 【强制】中括号是数组类型的一部分，数组定义如下：String[] args;*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-【强制】POJO-类中布尔类型的变量，都不要加-is，否则部分框架解析会引起序列化错误。"><span class="nav-number">1.8.</span> <span class="nav-text">8. 【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用-单数形式，但是类名如果有复数含义，类名可以使用复数形式。"><span class="nav-number">1.9.</span> <span class="nav-text">9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-【强制】杜绝完全不规范的缩写，避免望文不知义。"><span class="nav-number">1.10.</span> <span class="nav-text">10. 【强制】杜绝完全不规范的缩写，避免望文不知义。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。"><span class="nav-number">1.11.</span> <span class="nav-text">11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁-性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是-与接口方法相关，并且是整个应用的基础常量。"><span class="nav-number">1.12.</span> <span class="nav-text">12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-接口和实现类的命名有两套规则："><span class="nav-number">1.13.</span> <span class="nav-text">13. 接口和实现类的命名有两套规则：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）【强制】对于-Service-和-DAO-类，基于-SOA-的理念，暴露出来的服务一定是接口，内部的实现类用-Impl-的后缀与接口区别。"><span class="nav-number">1.13.1.</span> <span class="nav-text">1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able-的形式）。"><span class="nav-number">1.13.2.</span> <span class="nav-text">2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。"><span class="nav-number">1.14.</span> <span class="nav-text">14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-【参考】各层命名规约："><span class="nav-number">1.15.</span> <span class="nav-text">15. 【参考】各层命名规约：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-Service-DAO-层方法命名规约"><span class="nav-number">1.15.1.</span> <span class="nav-text">A) Service/DAO 层方法命名规约</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-领域模型命名规约"><span class="nav-number">1.15.2.</span> <span class="nav-text">B) 领域模型命名规约</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-常量定义"><span class="nav-number">2.</span> <span class="nav-text">(二) 常量定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。"><span class="nav-number">2.1.</span> <span class="nav-text">1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】long-或者-Long-初始赋值时，必须使用大写的-L，不能是小写的-l，小写容易跟数字-1-混淆，造成误解。"><span class="nav-number">2.2.</span> <span class="nav-text">2. 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。"><span class="nav-number">2.3.</span> <span class="nav-text">3. 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。"><span class="nav-number">2.4.</span> <span class="nav-text">4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）-跨应用共享常量：放置在二方库中，通常是-client-jar-中的-constant-目录下。"><span class="nav-number">2.4.1.</span> <span class="nav-text">1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）-应用内共享常量：放置在一方库的-modules-中的-constant-目录下。"><span class="nav-number">2.4.2.</span> <span class="nav-text">2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3）-子工程内部共享常量：即在当前子工程的-constant-目录下。"><span class="nav-number">2.4.3.</span> <span class="nav-text">3） 子工程内部共享常量：即在当前子工程的 constant 目录下。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4）-包内共享常量：即在当前包下单独的-constant-目录下。"><span class="nav-number">2.4.4.</span> <span class="nav-text">4） 包内共享常量：即在当前包下单独的 constant 目录下。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5）-类内共享常量：直接在类内部-private-static-final-定义。"><span class="nav-number">2.4.5.</span> <span class="nav-text">5） 类内共享常量：直接在类内部 private static final 定义。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。"><span class="nav-number">2.5.</span> <span class="nav-text">5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-代码格式"><span class="nav-number">3.</span> <span class="nav-text">(三) 代码格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】大括号的使用约定。"><span class="nav-number">3.1.</span> <span class="nav-text">1. 【强制】大括号的使用约定。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】-左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见-第-5-条下方正例提示。"><span class="nav-number">3.2.</span> <span class="nav-text">2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【强制】if-for-while-switch-do-等保留字与括号之间都必须加空格。"><span class="nav-number">3.3.</span> <span class="nav-text">3. 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【强制】任何二目、三目运算符的左右两边都需要加一个空格。"><span class="nav-number">3.4.</span> <span class="nav-text">4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【强制】缩进采用-4-个空格，禁止使用-tab-字符。"><span class="nav-number">3.5.</span> <span class="nav-text">5. 【强制】缩进采用 4 个空格，禁止使用 tab 字符。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【强制】单行字符数限制不超过-120-个，超出需要换行，换行时遵循如下原则："><span class="nav-number">3.6.</span> <span class="nav-text">6. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。"><span class="nav-number">3.7.</span> <span class="nav-text">7. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-【强制】IDE-的-text-file-encoding-设置为-UTF-8-IDE-中文件的换行符使用-Unix-格式，不要使用-windows-格式。"><span class="nav-number">3.8.</span> <span class="nav-text">8. 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。"><span class="nav-number">3.9.</span> <span class="nav-text">9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义-之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。"><span class="nav-number">3.10.</span> <span class="nav-text">10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义 之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-OOP-规约"><span class="nav-number">4.</span> <span class="nav-text">(四) OOP 规约</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成-本，直接用类名来访问即可。"><span class="nav-number">4.1.</span> <span class="nav-text">1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】所有的覆写方法，必须加-Override-注解。"><span class="nav-number">4.2.</span> <span class="nav-text">2. 【强制】所有的覆写方法，必须加@Override 注解。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【强制】相同参数类型，相同业务含义，才可以使用-Java-的可变参数，避免使用-Object。"><span class="nav-number">4.3.</span> <span class="nav-text">3. 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生-影响。接口过时必须加-Deprecated-注解，并清晰地说明采用的新接口或者新服务是什么。"><span class="nav-number">4.4.</span> <span class="nav-text">4. 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【强制】不能使用过时的类或方法。"><span class="nav-number">4.5.</span> <span class="nav-text">5. 【强制】不能使用过时的类或方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【强制】Object-的-equals-方法容易抛空指针异常，应使用常量或确定有值的对象来调用-equals。"><span class="nav-number">4.6.</span> <span class="nav-text">6. 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【强制】所有的相同类型的包装类对象之间值的比较，全部使用-equals-方法比较。"><span class="nav-number">4.7.</span> <span class="nav-text">7. 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-关于基本数据类型与包装数据类型的使用标准如下："><span class="nav-number">4.8.</span> <span class="nav-text">8. 关于基本数据类型与包装数据类型的使用标准如下：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1）【强制】所有的-POJO-类属性必须使用包装数据类型。"><span class="nav-number">4.8.1.</span> <span class="nav-text">1）【强制】所有的 POJO 类属性必须使用包装数据类型。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）【强制】RPC-方法的返回值和参数必须使用包装数据类型。"><span class="nav-number">4.8.2.</span> <span class="nav-text">2）【强制】RPC 方法的返回值和参数必须使用包装数据类型。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3）【推荐】所有的局部变量使用基本数据类型。"><span class="nav-number">4.8.3.</span> <span class="nav-text">3）【推荐】所有的局部变量使用基本数据类型。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-【强制】定义-DO-DTO-VO-等-POJO-类时，不要设定任何属性默认值。"><span class="nav-number">4.9.</span> <span class="nav-text">9. 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-【强制】序列化类新增属性时，请不要修改-serialVersionUID-字段，避免反序列失败；如-果完全不兼容升级，避免反序列化混乱，那么请修改-serialVersionUID-值。"><span class="nav-number">4.10.</span> <span class="nav-text">10. 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在-init-方法中。"><span class="nav-number">4.11.</span> <span class="nav-text">11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-【强制】POJO-类必须写-toString-方法。使用-IDE-的中工具：source-gt-generate-toString-时，如果继承了另一个-POJO-类，注意在前面加一下-super-toString。"><span class="nav-number">4.12.</span> <span class="nav-text">12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-【推荐】使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无-内容的检查，否则会有抛-IndexOutOfBoundsException-的风险。"><span class="nav-number">4.13.</span> <span class="nav-text">13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，-便于阅读。"><span class="nav-number">4.14.</span> <span class="nav-text">14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起， 便于阅读。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-【推荐】-类内方法定义顺序依次是：公有方法或保护方法-gt-私有方法-gt-getter-setter-方法。"><span class="nav-number">4.15.</span> <span class="nav-text">15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-【推荐】setter-方法中，参数名称与类成员变量名称一致，this-成员名-参数名。在-getter-setter-方法中，不要增加业务逻辑，增加排查问题的难度。"><span class="nav-number">4.16.</span> <span class="nav-text">16. 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-【推荐】循环体内，字符串的连接方式，使用-StringBuilder-的-append-方法进行扩展。"><span class="nav-number">4.17.</span> <span class="nav-text">17. 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-【推荐】final-可以声明类、成员变量、方法、以及本地变量，下列情况使用final-关键字："><span class="nav-number">4.18.</span> <span class="nav-text">18.【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用final 关键字：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-【推荐】慎用-Object-的-clone-方法来拷贝对象。"><span class="nav-number">4.19.</span> <span class="nav-text">19. 【推荐】慎用 Object 的 clone 方法来拷贝对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-【推荐】类成员与方法访问控制从严："><span class="nav-number">4.20.</span> <span class="nav-text">20. 【推荐】类成员与方法访问控制从严：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-集合处理"><span class="nav-number">5.</span> <span class="nav-text">(五) 集合处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】关于-hashCode-和-equals-的处理，遵循如下规则："><span class="nav-number">5.1.</span> <span class="nav-text">1. 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】ArrayList-的-subList-结果不可强转成-ArrayList，否则会抛出-ClassCastException"><span class="nav-number">5.2.</span> <span class="nav-text">2. 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【强制】-在-subList-场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增-加、删除均产生-ConcurrentModificationException-异常。"><span class="nav-number">5.3.</span> <span class="nav-text">3. 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 ConcurrentModificationException 异常。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【强制】使用集合转数组的方法，必须使用集合的-toArray-T-array-，传入的是类型完全一样的数组，大小就是-list-size-。"><span class="nav-number">5.4.</span> <span class="nav-text">4. 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【强制】使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。"><span class="nav-number">5.5.</span> <span class="nav-text">5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方-法，而-lt-super-T-gt-不能使用-get-方法，做为接口调用赋值时易出错。"><span class="nav-number">5.6.</span> <span class="nav-text">6. 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而&lt;? super T&gt;不能使用 get 方法，做为接口调用赋值时易出错。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【强制】不要在-foreach-循环里进行元素的-remove-add-操作。remove-元素请使用-Iterato-方式，如果并发操作，需要对-Iterator-对象加锁。"><span class="nav-number">5.7.</span> <span class="nav-text">7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterato 方式，如果并发操作，需要对 Iterator 对象加锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-【强制】-在-JDK7-版本及以上，Comparator-要满足如下三个条件，不然-Arrays-sort，Collections-sort-会报-IllegalArgumentException-异常。"><span class="nav-number">5.8.</span> <span class="nav-text">8. 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-【推荐】集合初始化时，指定集合初始值大小。"><span class="nav-number">5.9.</span> <span class="nav-text">9. 【推荐】集合初始化时，指定集合初始值大小。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-【推荐】使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。"><span class="nav-number">5.10.</span> <span class="nav-text">10. 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-【推荐】高度注意-Map-类集合-K-V-能不能存储-null-值的情况，如下表格："><span class="nav-number">5.11.</span> <span class="nav-text">11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-【参考】合理利用好集合的有序性-sort-和稳定性-order-，避免集合的无序性-unsort-和不稳定性-unorder-带来的负面影响。"><span class="nav-number">5.12.</span> <span class="nav-text">12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-【参考】利用-Set-元素唯一的特性，可以快速对一个集合进行去重操作，避免使用-List-的-contains-方法进行遍历、对比、去重操作。"><span class="nav-number">5.13.</span> <span class="nav-text">13. 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-并发处理"><span class="nav-number">6.</span> <span class="nav-text">(六) 并发处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><span class="nav-number">6.1.</span> <span class="nav-text">1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><span class="nav-number">6.2.</span> <span class="nav-text">2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"><span class="nav-number">6.3.</span> <span class="nav-text">3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【强制】线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"><span class="nav-number">6.4.</span> <span class="nav-text">4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【强制】SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为static，必须加锁，或者使用-DateUtils-工具类。"><span class="nav-number">6.5.</span> <span class="nav-text">5. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能-锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"><span class="nav-number">6.6.</span> <span class="nav-text">6. 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造-成死锁。"><span class="nav-number">6.7.</span> <span class="nav-text">7. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加-锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。"><span class="nav-number">6.8.</span> <span class="nav-text">8. 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-【强制】多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获-抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。"><span class="nav-number">6.9.</span> <span class="nav-text">9. 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获 抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-【推荐】使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown方法，线程执行代码注意-catch-异常，确保-countDown-方法可以执行，避免主线程无法执行-至-await-方法，直到超时才返回结果。"><span class="nav-number">6.10.</span> <span class="nav-text">10. 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行 至 await 方法，直到超时才返回结果。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-【推荐】避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降。"><span class="nav-number">6.11.</span> <span class="nav-text">11. 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-【推荐】在并发场景下，通过双重检查锁（double-checked-locking）实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-，推荐问-题解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型。"><span class="nav-number">6.12.</span> <span class="nav-text">12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问 题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-【参考】volatile-解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，-但是如果多写，同样无法解决线程安全问题。如果是-count-操作，使用如下类实现：-AtomicInteger-count-new-AtomicInteger-count-addAndGet-1-如果是-JDK8，推荐使用-LongAdder-对象，比-AtomicLong-性能更好（减少乐观锁的重试次数）。"><span class="nav-number">6.13.</span> <span class="nav-text">13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在-开发过程中可以使用其它数据结构或加锁来规避此风险。"><span class="nav-number">6.14.</span> <span class="nav-text">14. 【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在 开发过程中可以使用其它数据结构或加锁来规避此风险。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-【参考】ThreadLocal-无法解决共享对象的更新问题，ThreadLocal-对象建议使用-static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享-此静态变量-，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象-只-要是这个线程内定义的-都可以操控这个变量。"><span class="nav-number">6.15.</span> <span class="nav-text">15. 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享 此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-控制语句"><span class="nav-number">7.</span> <span class="nav-text">(七) 控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】在一个-switch-块内，每个-case-要么通过-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；在一个-switch-块内，都必须包含一个-default-语句并且-放在最后，即使它什么代码也没有。"><span class="nav-number">7.1.</span> <span class="nav-text">1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且 放在最后，即使它什么代码也没有。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】在-if-else-for-while-do-语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if-condition-statements"><span class="nav-number">7.2.</span> <span class="nav-text">2. 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【推荐】表达异常的分支时，少用-if-else-方式，这种方式可以改写成："><span class="nav-number">7.3.</span> <span class="nav-text">3. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【推荐】除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复-杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"><span class="nav-number">7.4.</span> <span class="nav-text">4. 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复 杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、-获取数据库连接，进行不必要的-try-catch-操作（这个-try-catch-是否可以移至循环体外）。"><span class="nav-number">7.5.</span> <span class="nav-text">5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、 获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。"><span class="nav-number">7.6.</span> <span class="nav-text">6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【参考】下列情形，需要进行参数校验："><span class="nav-number">7.7.</span> <span class="nav-text">7. 【参考】下列情形，需要进行参数校验：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-【参考】下列情形，不需要进行参数校验："><span class="nav-number">7.8.</span> <span class="nav-text">8. 【参考】下列情形，不需要进行参数校验：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-注释规约"><span class="nav-number">8.</span> <span class="nav-text">(八) 注释规约</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】类、类属性、类方法的注释必须使用-Javadoc-规范，使用-内容-格式，不得使用-xxx-方式。"><span class="nav-number">8.1.</span> <span class="nav-text">1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用 //xxx 方式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、-异常说明外，还必须指出该方法做什么事情，实现什么功能。"><span class="nav-number">8.2.</span> <span class="nav-text">2. 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【强制】所有的类都必须添加创建者和创建日期。"><span class="nav-number">8.3.</span> <span class="nav-text">3. 【强制】所有的类都必须添加创建者和创建日期。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【强制】方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释-使用-注释，注意与代码对齐。"><span class="nav-number">8.4.</span> <span class="nav-text">4. 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释 使用/ /注释，注意与代码对齐。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。"><span class="nav-number">8.5.</span> <span class="nav-text">5. 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持-英文原文即可。"><span class="nav-number">8.6.</span> <span class="nav-text">6. 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑-等的修改。"><span class="nav-number">8.7.</span> <span class="nav-text">7. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。"><span class="nav-number">8.8.</span> <span class="nav-text">8. 【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含-义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同-天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看-的，使其能够快速接替自己的工作。"><span class="nav-number">8.9.</span> <span class="nav-text">9. 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看 的，使其能够快速接替自己的工作。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的-一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。"><span class="nav-number">8.10.</span> <span class="nav-text">10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的 一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，-经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。"><span class="nav-number">8.11.</span> <span class="nav-text">11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九-其它"><span class="nav-number">9.</span> <span class="nav-text">(九) 其它</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><span class="nav-number">9.1.</span> <span class="nav-text">1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-【强制】velocity-调用-POJO-类的属性时，建议直接使用属性名取值即可，模板引擎会自动按-规范调用-POJO-的-getXxx-，如果是-boolean-基本数据类型变量（boolean-命名不需要加-is前缀），会自动调用-isXxx-方法。"><span class="nav-number">9.2.</span> <span class="nav-text">2. 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按 规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-【强制】后台输送给页面的变量必须加-var-——中间的感叹号。"><span class="nav-number">9.3.</span> <span class="nav-text">3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-【强制】注意-Math-random-这个方法返回是-double-类型，注意取值的范围-0≤x-lt-1（能够-取到零值，注意除零异常），如果想获取整数类型的随机数，不要将-x-放大-10-的若干倍然后-取整，直接使用-Random-对象的-nextInt-或者-nextLong-方法。"><span class="nav-number">9.4.</span> <span class="nav-text">4. 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime"><span class="nav-number">9.5.</span> <span class="nav-text">5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-【推荐】不要在视图模板中加入任何复杂的逻辑。"><span class="nav-number">9.6.</span> <span class="nav-text">6. 【推荐】不要在视图模板中加入任何复杂的逻辑。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"><span class="nav-number">9.7.</span> <span class="nav-text">7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性-等要坚决从程序中清理出去，避免造成过多垃圾。"><span class="nav-number">9.8.</span> <span class="nav-text">8. 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性 等要坚决从程序中清理出去，避免造成过多垃圾。</span></a></li></ol></li></ol></div>
              

            </div>
          </section>
        <!--/noindex-->
        
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xin Meng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://mengxin.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://notes.mengxin.science/2017/06/05/ali-java-dev-doc-note-1/';
          this.page.identifier = '2017/06/05/ali-java-dev-doc-note-1/';
          this.page.title = '阿里Java开发手册笔记-编程规约';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://mengxin.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        },
        TeX: { equationNumbers: { autoNumber: "AMS" }}
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
