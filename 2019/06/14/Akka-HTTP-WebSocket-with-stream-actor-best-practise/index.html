<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Akka,WebSocket,Actor," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="摘要：本文介绍如何使用Actor 和 Stream 来处理 Akka Http WebSocket消息。该实现具有如下特性：  一个 Actor 可以处理多个 WebSocket 客户端终止 WebSocket，服务端可以收到通知 更加容易集群化，并且使用 Actor Router 进行负载平衡">
<meta name="keywords" content="Akka,WebSocket,Actor">
<meta property="og:type" content="article">
<meta property="og:title" content="Akka Http WebSocket with Stream and Actor 最佳实践">
<meta property="og:url" content="https://notes.mengxin.science/2019/06/14/Akka-HTTP-WebSocket-with-stream-actor-best-practise/index.html">
<meta property="og:site_name" content="Xin&#39;s Notes">
<meta property="og:description" content="摘要：本文介绍如何使用Actor 和 Stream 来处理 Akka Http WebSocket消息。该实现具有如下特性：  一个 Actor 可以处理多个 WebSocket 客户端终止 WebSocket，服务端可以收到通知 更加容易集群化，并且使用 Actor Router 进行负载平衡">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-12-21T09:52:36.028Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Akka Http WebSocket with Stream and Actor 最佳实践">
<meta name="twitter:description" content="摘要：本文介绍如何使用Actor 和 Stream 来处理 Akka Http WebSocket消息。该实现具有如下特性：  一个 Actor 可以处理多个 WebSocket 客户端终止 WebSocket，服务端可以收到通知 更加容易集群化，并且使用 Actor Router 进行负载平衡">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'LRRR8WO27T',
      apiKey: '52f38cdd494149d36c3b9a986a36836c',
      indexName: 'prod_notes',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://notes.mengxin.science/2019/06/14/Akka-HTTP-WebSocket-with-stream-actor-best-practise/"/>





  <title> Akka Http WebSocket with Stream and Actor 最佳实践 | Xin's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-40931165-6', 'auto');
  ga('send', 'pageview');
</script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xin's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Develop Notes</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<div id="google_translate_element"></div><script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'zh-CN', layout: google.translate.TranslateElement.InlineLayout.SIMPLE, multilanguagePage: true, gaTrack: true, gaId: 'UA-40931165-7'}, 'google_translate_element');
}
</script><script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://notes.mengxin.science/2019/06/14/Akka-HTTP-WebSocket-with-stream-actor-best-practise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xin Meng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xin's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                Akka Http WebSocket with Stream and Actor 最佳实践
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T23:00:00+00:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index">
                    <span itemprop="name">Knowledge</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/Akka-HTTP-WebSocket-with-stream-actor-best-practise/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/06/14/Akka-HTTP-WebSocket-with-stream-actor-best-practise/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>摘要：本文介绍如何使用Actor 和 Stream 来处理 Akka Http WebSocket消息。该实现具有如下特性：</p>
<ol>
<li>一个 Actor 可以处理多个 WebSocket</li>
<li>客户端终止 WebSocket，服务端可以收到通知</li>
<li>更加容易集群化，并且使用 Actor Router 进行负载平衡</li>
</ol>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>我们主要参考如下两篇文章，其中第二篇个人感觉更好一点，前一个会有内存溢出问题。</p>
<ol>
<li><a href="http://ticofab.io/akka-http-websocket-example/" target="_blank" rel="noopener">Akka Http, handle Websockets with Actors</a></li>
<li><a href="https://stackoverflow.com/a/41359874/2000468" target="_blank" rel="noopener">Answer on StackOverflow</a></li>
</ol>
<h3 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h3><p>基本思路如下图：</p>
<ol>
<li>Source 处理从 Actor 向 Client 发送的消息</li>
<li>Sink 处理从 Client 向 Actor 发送的消息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                      --&gt; Sink    --&gt;</span><br><span class="line">Client |                |  Actor</span><br><span class="line">					  &lt;-- Source  &lt;--</span><br></pre></td></tr></table></figure>
<h2 id="Implementation-实现"><a href="#Implementation-实现" class="headerlink" title="Implementation 实现"></a>Implementation 实现</h2><p>分为4步</p>
<h3 id="Sink-Source-Flow"><a href="#Sink-Source-Flow" class="headerlink" title="Sink Source Flow"></a>Sink Source Flow</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chatActorFlow</span></span>(connectionId: <span class="type">UUID</span>) : <span class="type">Flow</span>[<span class="type">String</span>, <span class="type">String</span>, <span class="type">Any</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sink = <span class="type">Flow</span>[<span class="type">String</span>]</span><br><span class="line">      .map(msg =&gt; <span class="type">Protocol</span>.<span class="type">SignedMessage</span>(connectionId, msg))</span><br><span class="line">      .to(<span class="type">Sink</span>.actorRef(chatRef, <span class="type">Protocol</span>.<span class="type">CloseConnection</span>(connectionId)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> source = <span class="type">Source</span>.actorRef(<span class="number">16</span>, <span class="type">OverflowStrategy</span>.fail)</span><br><span class="line">      .mapMaterializedValue &#123;</span><br><span class="line">        actor : <span class="type">ActorRef</span> =&gt; &#123;</span><br><span class="line">          chatRef ! <span class="type">Protocol</span>.<span class="type">OpenConnection</span>(actor, connectionId)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Flow</span>.fromSinkAndSource(sink, source)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是整个实现的核心，通过定义 <code>Flow</code>，连接了客户端和服务端完成基本的消息传递。</p>
<h4 id="Source-actorRef"><a href="#Source-actorRef" class="headerlink" title="Source.actorRef"></a>Source.actorRef</h4><p>首先我们理解一下： <code>Source.actorRef(16, OverflowStrategy.fail)</code>，我们参考 <code>Source.actorRef</code> 的<a href="https://doc.akka.io/api/akka/current/akka/stream/scaladsl/Source$.html#actorRef%5BT%5D%28bufferSize:Int,overflowStrategy:akka.stream.OverflowStrategy%29:akka.stream.scaladsl.Source%5BT,akka.actor.ActorRef%5D" target="_blank" rel="noopener">官方 API 文档</a> （该文档位于 <code>Companion object Source</code>）：</p>
<blockquote>
<p>Creates a Source that is materialized as an akka.actor.ActorRef.</p>
</blockquote>
<p>我们可以发现，这个方法实际上是创建了一个 <code>Source</code>，这个 <code>Source</code> 的特点就是将会被 Materialized 为 <a href="https://doc.akka.io/api/akka/current/akka/actor/ActorRef.html" target="_blank" rel="noopener">akka.actor.ActorRef</a>。</p>
<blockquote>
<p>Messages sent to this actor will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received.</p>
</blockquote>
<p>我们通过这种方法创建的 <code>Source</code>的功能就是，如果向其中的 Actor 发送消息，这个消息将会被释放到 stream 中。所以这样一来，Actor 就自然的和 Stream 关联在了一起，我们也可以从其<a href="https://github.com/akka/akka/blob/v2.5.23/akka-stream/src/main/scala/akka/stream/scaladsl/Source.scala#L518" target="_blank" rel="noopener">实现源码</a>探知真相：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Source</span></span><br><span class="line">      .fromGraph(<span class="keyword">new</span> <span class="type">ActorRefSource</span>(bufferSize, overflowStrategy, completionMatcher, failureMatcher))</span><br><span class="line">      .withAttributes(<span class="type">DefaultAttributes</span>.actorRefSource)</span><br></pre></td></tr></table></figure>
<h4 id="mapMaterializedValue"><a href="#mapMaterializedValue" class="headerlink" title="mapMaterializedValue"></a>mapMaterializedValue</h4><p>下面一个重要操作是 <code>mapMaterializedValue</code>， 这个方法目标很简单就是把一个 <code>Stream</code> 立即 <code>Materialize</code>，对于我们上面创建的<code>Source</code>，物质化后就是一个 <code>ActorRef</code>，我们就可以针对这个 <code>ActorRef</code> 进行业务逻辑的操控了。</p>
<p>注：什么是 <code>Materialization</code>？简单的说就是把蓝图实现了，如果我们把Flow 的设计看做是一个水管管道的设计，那么物质化的过程就是打开所有的阀门和开源，水将会从源头流经整个管道系统。</p>
<blockquote>
<p>It is important to remember that even after constructing the <code>RunnableGraph</code> by connecting all the source, sink and different operators, no data will flow through it until it is materialized. <strong>Materialization</strong> is the process of <strong>allocating</strong> all resources needed to run the computation described by a Graph (in Akka Streams this will often involve starting up Actors).</p>
</blockquote>
<h4 id="ActorRef"><a href="#ActorRef" class="headerlink" title="ActorRef"></a>ActorRef</h4><p>拿到了和客户端 <code>Stream</code> 建立桥梁的 <code>ActorRef</code>，我们如何使用呢?</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actor : <span class="type">ActorRef</span> =&gt; &#123;</span><br><span class="line">          chatRef ! <span class="type">Protocol</span>.<span class="type">OpenConnection</span>(actor, connectionId)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里只做了一件事，就是基于该 <code>ActorRef</code> 和连接的<code>ID</code>构造 <code>Protocol.OpenConnection</code> 消息，把该消息发送个 <code>chatRef</code>。后面这个 <code>Actor</code> 可以看做是所有的 <code>WebSocket</code>的控制者。下面的章节我们会介绍这个动作的用途。</p>
<h4 id="Sink-from-the-message"><a href="#Sink-from-the-message" class="headerlink" title="Sink from the message"></a>Sink from the message</h4><p>前面创建的 <code>Source</code> 已经解决了如何连接 <code>WebSocket</code> 客户端，并通过 <code>Actor</code> 向其发送消息，那么如何接受来自客户端的消息呢？这里创建了 <code>Sink</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sink = <span class="type">Flow</span>[<span class="type">String</span>]</span><br><span class="line">     .map(msg =&gt; <span class="type">Protocol</span>.<span class="type">SignedMessage</span>(connectionId, msg))</span><br><span class="line">  .to(<span class="type">Sink</span>.actorRef(chatRef, <span class="type">Protocol</span>.<span class="type">CloseConnection</span>(connectionId)))</span><br></pre></td></tr></table></figure>
<p>该 Flow 是传递 String 类型的，表示我们只能用它处理 String 消息，然后消息字符串会被重新打包为一个 <code>Protocol.SignedMessage</code>，这个结构包含了 <code>connectionId</code>，从而能够确定该消息是哪个 <code>WebSocket</code> 连接发送。</p>
<h4 id="Sink-actorRef"><a href="#Sink-actorRef" class="headerlink" title="Sink.actorRef"></a>Sink.actorRef</h4><blockquote>
<p>Sends the elements of the stream to the given ActorRef.</p>
</blockquote>
<p>这个方法对和 <code>Source.actorRef</code> 对应起来的：<code>Stream</code> 收到的消息将会转发给 <code>ActorRef</code>。</p>
<p>我们可以用下面这张图概括一下这两个 <code>actorRef</code> 的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client &lt;-- Stream &lt;-- Source.actorRef.mapMaterializedValue&#123;ar=&gt;???&#125; &lt;-- Actor:ar</span><br><span class="line">Client --&gt; Stream --&gt; Sink.actorRef(ar) --&gt; Actor:ar</span><br></pre></td></tr></table></figure>
<h4 id="Flow-map-and-to"><a href="#Flow-map-and-to" class="headerlink" title="Flow map and to"></a>Flow map and to</h4><blockquote>
<p>def map<a href="f: (Out" target="_blank" rel="noopener">T</a> ⇒ T): Repr[T]</p>
<p>Transform this stream by applying the given function to each of the elements as they pass through this processing step.<br>Adheres to the ActorAttributes.SupervisionStrategy attribute.<br>Emits when the mapping function returns an element<br>Backpressures when downstream backpressures<br>Completes when upstream completes<br>Cancels when downstream cancels</p>
<p>def to<a href="sink: Graph[SinkShape[Out], Mat2]" target="_blank" rel="noopener">Mat2</a>: Sink[In, Mat]</p>
<p>Connect this Flow to a Sink, concatenating the processing steps of both. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          +------------------------------+</span><br><span class="line">          | Resulting Sink[In, Mat]      |</span><br><span class="line">          |                              |</span><br><span class="line">          |  +------+          +------+  |</span><br><span class="line">          |  |      |          |      |  |</span><br><span class="line">In ~~&gt; | flow | ~~Out~~&gt; | sink |  |</span><br><span class="line">          |  |   Mat|          |     M|  |</span><br><span class="line">          |  +------+          +------+  |</span><br><span class="line">          +------------------------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The materialized value of the combined Sink will be the materialized value of the current flow  (ignoring the given Sink’s value), use toMat if a different strategy is needed.</p>
</blockquote>
<p>综上可以，这个定义就是将 <code>String</code> 类型的 <code>Flow</code>，将其连接到一个 <code>Sink</code>，而这个 <code>Sink</code> 的功能就是将 <code>Stream</code> 上流动的 <code>String</code> 消息传递给 <code>Actor</code>，而这个 <code>Actor</code> 正是我们前面提到的所有 <code>WebSocket</code> 连接的控制者。</p>
<p><code>def actorRef[T](ref: ActorRef, onCompleteMessage: Any)</code> 的第二个参数表示：</p>
<blockquote>
<p>If the target actor terminates the stream will be canceled. When the stream is completed successfully the given onCompleteMessage will be sent to the destination actor. When the stream is completed with failure a akka.actor.Status.Failure message will be sent to the destination actor.</p>
</blockquote>
<p>所以一旦当前的 <code>WebSocket</code> 被终止，其 <code>Stream</code> 就会被 <code>Complete</code>，这时候这个消息就会传递给 <code>Actor</code>，这样控制者就有能力来处理 <code>WebSocket</code>被终止后的善后工作，比如清理相关的数据。</p>
<h4 id="Flow-fromSinkAndSource-sink-source"><a href="#Flow-fromSinkAndSource-sink-source" class="headerlink" title="Flow.fromSinkAndSource(sink, source)"></a>Flow.fromSinkAndSource(sink, source)</h4><p>组合 <code>Sink</code> 和 <code>Source</code>，创建 <code>Flow</code>。</p>
<blockquote>
<p>def fromSinkAndSource<a href="sink: Graph[SinkShape[I], _], source: Graph[SourceShape[O], _]" target="_blank" rel="noopener">I, O</a>: Flow[I, O, NotUsed]</p>
<p>Creates a Flow from a Sink and a Source where the Flow’s input will be sent to the Sink and the Flow’s output will come from the Source.<br>The resulting flow can be visualized as:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          +----------------------------------------------+</span><br><span class="line">          | Resulting Flow[I, O, NotUsed]                |</span><br><span class="line">          |                                              |</span><br><span class="line">          |  +---------+                  +-----------+  |</span><br><span class="line">          |  |         |                  |           |  |</span><br><span class="line">I  ~~&gt; | Sink[I] | [no-connection!] | Source[O] | ~~&gt; O</span><br><span class="line">          |  |         |                  |           |  |</span><br><span class="line">          |  +---------+                  +-----------+  |</span><br><span class="line">          +----------------------------------------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The completion of the Sink and Source sides of a Flow constructed using this method are independent. So if the Sink receives a completion signal, the Source side will remain unaware of that. If you are looking to couple the termination signals of the two sides use Flow.fromSinkAndSourceCoupled instead.</p>
</blockquote>
<p>我们在看这个文档的时候一定要注意，图中的 <code>I</code> 和 <code>O</code>，也就是  <code>In</code> 和 <code>Out</code> 在我们这个场景中都对应这 <code>WebSocket</code> 的客户端，因为 <code>WebSocket</code> 是双向的，所以万万要注意这一点。至于为什么这个 <code>Flow</code> 能够为双向的 <code>WebSocket</code>服务，我们在 <code>Akka Http WebSocket</code> 的介绍中会详细介绍其原理。</p>
<h3 id="Message-Handle-Flow"><a href="#Message-Handle-Flow" class="headerlink" title="Message Handle Flow"></a>Message Handle Flow</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">websocketFlow</span></span>: <span class="type">Flow</span>[<span class="type">Message</span>, <span class="type">Message</span>, <span class="type">Any</span>] =</span><br><span class="line">    <span class="type">Flow</span>[<span class="type">Message</span>]</span><br><span class="line">      .mapAsync(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">TextMessage</span>.<span class="type">Strict</span>(s) =&gt; <span class="type">Future</span>.successful(s)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">TextMessage</span>.<span class="type">Streamed</span>(s) =&gt; s.runFold(<span class="string">""</span>)(_ + _)</span><br><span class="line">        <span class="keyword">case</span> b: <span class="type">BinaryMessage</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"Binary message cannot be handled"</span>)</span><br><span class="line">      &#125;.via(chatActorFlow(<span class="type">UUID</span>.randomUUID()))</span><br><span class="line">      .map(<span class="type">TextMessage</span>(_))</span><br></pre></td></tr></table></figure>
<p>前面介绍了通过 <code>Sink</code> 和 <code>Source</code> 构造了一个 <code>Flow</code>， 这个 <code>Flow</code> 已经具有以下能力：</p>
<ol>
<li>Sink：从 Stream 获取 String 类型的数据，传递给总操控者 Actor （chatActerRef）</li>
<li>Source：向某个特定的 Actor（ar） 发送消息，消息可以传递给 Stream</li>
<li>Stream 被终止或取消时，将会有特殊消息（Protocol.CloseConnection）发送给总操控者 Actor （chatActerRef）</li>
<li>特定的 Actor（ar） 创建的时候，将会有特殊消息（Protocol.OpenConnection）发送给总操控者 Actor （chatActerRef）</li>
</ol>
<p>这里我们利用 <code>via</code> 关键字，将处理 <code>WebSocket</code> 消息的 <code>Flow</code> 进行连接，从而创建出我们最终用于处理 <code>WebSocket</code> 的 <code>Flow</code></p>
<blockquote>
<p>def via<a href="flow: Graph[FlowShape[Out, T], Mat2]" target="_blank" rel="noopener">T, Mat2</a>: Repr[T]</p>
<p>Transform this Flow by appending the given processing steps.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          +---------------------------------+</span><br><span class="line">          | Resulting Flow[In, T, Mat]  |</span><br><span class="line">          |                                 |</span><br><span class="line">          |  +------+             +------+  |</span><br><span class="line">          |  |      |             |      |  |</span><br><span class="line">In ~~&gt; | this |  ~~Out~~&gt;   | flow | ~~&gt; T</span><br><span class="line">          |  |   Mat|             |     M|  |</span><br><span class="line">          |  +------+             +------+  |</span><br><span class="line">          +---------------------------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The materialized value of the combined Flow will be the materialized value of the current flow (ignoring the other Flow’s value), use viaMat if a different strategy is needed.</p>
</blockquote>
<h4 id="Akka-Http-WebSocket-Message-type"><a href="#Akka-Http-WebSocket-Message-type" class="headerlink" title="Akka Http WebSocket Message type"></a>Akka Http WebSocket Message type</h4><p>通过这个 Flow 的定义，我们可以看到，其 In 和 Out 的类型都是  <code>Message</code>，这是 <code>Akka HTTP Scala DSL</code> 描述 <code>WebSocket</code> 消息的抽象模型，并且包含两种类型： <code>TextMessage</code> 和 <code>BinaryMessage</code>。这里我们处理简单的 <code>TextMessage</code>，收到每个消息后使用 <code>mapAsync</code> 进行处理，处理方式很简单，直接把数据传入 downstream。</p>
<blockquote>
<p>def mapAsync<a href="parallelism: Int" target="_blank" rel="noopener">T</a>(f: (Out) ⇒ Future[T]): Repr[T]</p>
<p>  Transform this stream by applying the given function to each of the elements as they pass through this processing step. The function returns a Future and the value of that future will be emitted downstream. The number of Futures that shall run in parallel is given as the first argument to mapAsync. These Futures may complete in any order, but the elements that are emitted downstream are in the same order as received from upstream.<br>If the function f throws an exception or if the Future is completed with failure and the supervision decision is akka.stream.Supervision.Stop the stream will be completed with failure.<br>If the function f throws an exception or if the Future is completed with failure and the supervision decision is akka.stream.Supervision.Resume or akka.stream.Supervision.Restart the element is dropped and the stream continues.<br>The function f is always invoked on the elements in the order they arrive.<br>Adheres to the ActorAttributes.SupervisionStrategy attribute.<br>Emits when the Future returned by the provided function finishes for the next element in sequence<br>Backpressures when the number of futures reaches the configured parallelism and the downstream backpressures or the first future is not completed</p>
<p>Completes when upstream completes and all futures have been completed and all elements have been emitted</p>
<p>Cancels when downstream cancels</p>
</blockquote>
<h3 id="Message-Handle-Actor"><a href="#Message-Handle-Actor" class="headerlink" title="Message Handle Actor"></a>Message Handle Actor</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SignedMessage</span>(<span class="params">uuid: <span class="type">UUID</span>, msg: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class">    <span class="title">case</span> <span class="title">class</span> <span class="title">OpenConnection</span>(<span class="params">actor: <span class="type">ActorRef</span>, uuid: <span class="type">UUID</span></span>)</span></span><br><span class="line"><span class="class">    <span class="title">case</span> <span class="title">class</span> <span class="title">CloseConnection</span>(<span class="params">uuid: <span class="type">UUID</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ChatRef</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = withClients(<span class="type">Map</span>.empty[<span class="type">UUID</span>, <span class="type">ActorRef</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withClients</span></span>(clients: <span class="type">Map</span>[<span class="type">UUID</span>, <span class="type">ActorRef</span>]): <span class="type">Receive</span> = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SignedMessage</span>(uuid, msg) =&gt; clients.collect&#123;</span><br><span class="line">        <span class="keyword">case</span> (id, ar) <span class="keyword">if</span> id != uuid =&gt; ar ! msg</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">OpenConnection</span>(ar, uuid) <span class="keyword">if</span> clients.size == maximumClients =&gt; ar ! <span class="type">PoisonPill</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">OpenConnection</span>(ar, uuid) =&gt; context.become(withClients(clients.updated(uuid, ar)))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">CloseConnection</span>(uuid) =&gt; context.become(withClients(clients - uuid))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>集中处理 <code>WebSocket</code> 的 Actor 设计十分简单，首先定义一组协议消息，也就是 Actor 可以处理的消息，然后在分别实现处理代码，这里注意以下几点。</p>
<h4 id="Maintain-connection-ID-and-ctorRef"><a href="#Maintain-connection-ID-and-ctorRef" class="headerlink" title="Maintain connection ID and ctorRef"></a>Maintain connection ID and ctorRef</h4><p>由于我们在一个 <code>Actor</code> 中处理多个 <code>Connection</code>， 所以我们需要记录每个 <code>Connection</code> 的 ID 和对应的 <code>Actor</code> 的关系，这里使用一个 <code>Map</code> 来存储这个关系。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withClients</span></span>(clients: <span class="type">Map</span>[<span class="type">UUID</span>, <span class="type">ActorRef</span>])</span><br></pre></td></tr></table></figure>
<p>并且在每次收到 <code>OpenConnection</code> 和 <code>CloseConnection</code> 的时候更新该 <code>Map</code> 数据结构。</p>
<h4 id="Handle-receive-message"><a href="#Handle-receive-message" class="headerlink" title="Handle receive message"></a>Handle receive message</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">SignedMessage</span>(uuid, msg) =&gt; clients.collect&#123;</span><br><span class="line">       <span class="keyword">case</span> (id, ar) <span class="keyword">if</span> id != uuid =&gt; ar ! msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们收到某个 uuid 发送的消息后，我们可以通过维护的 Map 找到对应的 <code>Actor</code>，从而向该 <code>Connection</code> 进行反馈。</p>
<h3 id="Akka-Http-Route-with-Flow"><a href="#Akka-Http-Route-with-Flow" class="headerlink" title="Akka Http Route with Flow"></a>Akka Http Route with Flow</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> route = get &#123;</span><br><span class="line">    pathEndOrSingleSlash &#123;</span><br><span class="line">      handleWebSocketMessages(websocketFlow)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>外事具备只欠通风，我们只需要使用前面创建好的 Flow，然后利用 <code>Akka HTTP</code> 提供的工具就可以实现 <code>WebSocket</code> 的创建。</p>
<p><a href="https://doc.akka.io/docs/akka-http/current/routing-dsl/directives/websocket-directives/handleWebSocketMessages.html" target="_blank" rel="noopener">handleWebSocketMessages 文档</a></p>
<p>后面我们会专门解读  <code>Akka HTTP WebSocket</code> 支持的文档。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><p><script src="https://gist.github.com/xmeng1/c99da1fd6cdeac226c80f658d2144aa3.js"></script><br><!--stackedit_data:
eyJoaXN0b3J5IjpbMTkyODc1OTE2NF19
--></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Akka/" rel="tag"># Akka</a>
          
            <a href="/tags/WebSocket/" rel="tag"># WebSocket</a>
          
            <a href="/tags/Actor/" rel="tag"># Actor</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/24/python-machine-learning-note-2-data-visual/" rel="next" title="Python机器学习笔记2:简单数据可视化">
                <i class="fa fa-chevron-left"></i> Python机器学习笔记2:简单数据可视化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/15/scala-with-cats-type-class-thinking/" rel="prev" title="Scala with Cats 学习笔记1-Type Class 的思考">
                Scala with Cats 学习笔记1-Type Class 的思考 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
      
        
          <ul class="sidebar-nav motion-element">
            <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
              文章目录
            </li>
            <li class="sidebar-nav-overview" data-target="site-overview">
              站点概览
            </li>
          </ul>
        
      



      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar-2.jpg"
               alt="Xin Meng" />
          <p class="site-author-name" itemprop="name">Xin Meng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">152</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">162</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xmeng1" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/xinmeng_1" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/michealmeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.linkedin.com/in/xinmeng1" target="_blank" title="Linkedin">
                  
                    <i class="fa fa-fw fa-linkedin"></i>
                  
                  Linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/mengxin.city" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                  Facebook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/xinmeng1" target="_blank" title="Douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Douban
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/xinmeng1" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Next
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://theme-next.iissnan.com" title="Title" target="_blank">Title</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>
      
        
        <!--noindex-->
          <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
            <div class="post-toc">

              
                
              

              
                <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Theory"><span class="nav-number">1.1.</span> <span class="nav-text">Theory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-实现"><span class="nav-number">2.</span> <span class="nav-text">Implementation 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sink-Source-Flow"><span class="nav-number">2.1.</span> <span class="nav-text">Sink Source Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Source-actorRef"><span class="nav-number">2.1.1.</span> <span class="nav-text">Source.actorRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mapMaterializedValue"><span class="nav-number">2.1.2.</span> <span class="nav-text">mapMaterializedValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ActorRef"><span class="nav-number">2.1.3.</span> <span class="nav-text">ActorRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sink-from-the-message"><span class="nav-number">2.1.4.</span> <span class="nav-text">Sink from the message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sink-actorRef"><span class="nav-number">2.1.5.</span> <span class="nav-text">Sink.actorRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flow-map-and-to"><span class="nav-number">2.1.6.</span> <span class="nav-text">Flow map and to</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flow-fromSinkAndSource-sink-source"><span class="nav-number">2.1.7.</span> <span class="nav-text">Flow.fromSinkAndSource(sink, source)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Message-Handle-Flow"><span class="nav-number">2.2.</span> <span class="nav-text">Message Handle Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Akka-Http-WebSocket-Message-type"><span class="nav-number">2.2.1.</span> <span class="nav-text">Akka Http WebSocket Message type</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Message-Handle-Actor"><span class="nav-number">2.3.</span> <span class="nav-text">Message Handle Actor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Maintain-connection-ID-and-ctorRef"><span class="nav-number">2.3.1.</span> <span class="nav-text">Maintain connection ID and ctorRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handle-receive-message"><span class="nav-number">2.3.2.</span> <span class="nav-text">Handle receive message</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Akka-Http-Route-with-Flow"><span class="nav-number">2.4.</span> <span class="nav-text">Akka Http Route with Flow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ref"><span class="nav-number">3.</span> <span class="nav-text">Ref</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Source-Code"><span class="nav-number">3.1.</span> <span class="nav-text">Source Code</span></a></li></ol></li></ol></div>
              

            </div>
          </section>
        <!--/noindex-->
        
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xin Meng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://mengxin.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://notes.mengxin.science/2019/06/14/Akka-HTTP-WebSocket-with-stream-actor-best-practise/';
          this.page.identifier = '2019/06/14/Akka-HTTP-WebSocket-with-stream-actor-best-practise/';
          this.page.title = 'Akka Http WebSocket with Stream and Actor 最佳实践';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://mengxin.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        },
        TeX: { equationNumbers: { autoNumber: "AMS" }}
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
